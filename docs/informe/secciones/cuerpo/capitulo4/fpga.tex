%INTENTO 1

%En el Capítulo \ref{cap:int} se detalló que el sisetma desarrollado se compone de tres componentes principales, a saber: El Host, cuyo rol es llevado a cabo por una PC; la interfaz, integrada por el controlador FX2LP de Cypress y un FPGA, en este caso un Spartan-6 de Xilinx. A su vez, el Capítulo \ref{cap:fpga}, indica que el sistema interno del FPGA lleva una Maquina de Estados Finitos (MEF), cuya función es la de realizar el efectivo intercambio de datos con la interfaz, y un sistema genérico.
%
%Hasta acá se ha desarrollado la configuración de la interfaz y la implementación de la MEF. Sin embargo, es necesario, que el sistema pueda funcionar en forma autónoma, proveerle un sistema mínimo que pueda hacer las veces de fuente y sumidero de datos. Es por esto, que se dotó al sistema con una memoria FIFO con el objetivo de implementar un eco que permita realizar una evaluación de desempeño de la comunicación desarrollada. Así, se permite enviar mensajes desde una PC y que estos sean recibidos luego.
%
%\subsection{Implementación de la memoria FIFO en el FPGA}
%	La memoria FIFO sintetizada en el FPGA se obtuvo a través de la herramienta {\it Core Generator} provista por Xilinx junto con el entorno de desarrollo ISE, utilizado en este trabajo para el desarrollo\cite{XilinxInc}. La configruación seleccionada generó una memoria FIFO de 511 bytes, con puertos de entrada y salida dedicados, es decir uno de entrada y uno de salida, un bus de 16 bits de ancho. Posee señal de reconocimiento de escritura. También se dotó a la memoria generada con entradas de reloj y habilitación de bus independientes tanto para el puerto de entrada como el puerto de salida.
%	
%	
%INTENTO 2
%TODO debería decir como generar cada una de las señales internas propuesas en el capitulo correspondiente... la magen en cuestion es \ref{fpga:intersignal}
Con el objetivo de verificar el sistema desarrollado, se procedió a implementarlo en un sistema mínimo que sea capaz de utilizar la comunicación, de forma tal que el Host pueda establecer un enlace con el FPGA. Para ello, se implementó un sistema eco, es decir, un sistema que recibe los mensajes que envía el Host y, luego, los transmite para que el Host pueda recibirlos. De esta forma, el Host puede reconocer que los datos enviados no fueron perdidos ni modificados.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}[scale=.7]
		\begin{scope}[transform shape,node distance=4,>=latex,double distance=1.3]
			\node[simple](fx2lp){Interfaz FX2LP};
			
			\node[simple, rounded corners,minimum size=80] (PC)[left=2 of fx2lp]{PC};
			\draw[double,<->](PC) -- node[above]{USB} (fx2lp);
			
			\node[simple](mea)[right=of fx2lp]{Maquina de Estados Algorítmica};
			
			\draw[double,<->] ([yshift=3.5*110/4]fx2lp.east)-- node [above]{FDATA[15:0]} ([yshift=3.5*110/4]mea.west);
			\draw[double,<->] ([yshift=2.5*110/4]fx2lp.east)-- node [above]{FADDR[1:0]} ([yshift=2.5*110/4]mea.west);
			\draw[->] ([yshift=1.5*110/4]fx2lp.east)--node[above]{FLAG\_Vacío} ([yshift=1.5*110/4]mea.west);
			\draw[->]([yshift=.5*110/4]fx2lp.east)--node[above]{FLAG\_Lleno}([yshift=.5*110/4]mea.west);
			\draw[<-]([yshift=-.5*110/4]fx2lp.east)--node[above]{SLOE}([yshift=-.5*110/4]mea.west);
			\draw[<-]([yshift=-1.5*110/4]fx2lp.east)--node[above]{SLRD}([yshift=-1.5*110/4]mea.west);
			\draw[<-]([yshift=-2.5*110/4]fx2lp.east)--node[above]{SLWR}([yshift=-2.5*110/4]mea.west);
			\draw[<-]([yshift=-3.5*110/4]fx2lp.east)--node[above]{PKTEND}([yshift=-3.5*110/4]mea.west);
			
			\node[simple,minimum size=50](clk)[right=of mea.south east,anchor=south west] {PLL};
			\draw[<-]([]mea.east |- clk.west)--node[above]{Reloj}([]clk.west);
%			\draw[<-]([yshift=-1*80/3]mea.north east)--node[above]{Reloj}([yshift=-1*80/3]clk.north west);
%			\draw[<-]([yshift=-2*80/3]mea.north east)--node[above]{Reset}([yshift=-2*80/3]clk.north west);
			\node[rounded corners,simple, minimum size=50](clkSrc)[below=1 of clk]{Fuente de reloj};
			\draw[->](clkSrc) to (clk);
			
			\node[simple,minimum height=150,minimum width=50](interno)[right=of mea.north east,anchor=north west]{Memoria FIFO};
			\draw[double,->]([yshift=-.5*150/6]mea.north east)--node[above]{Dato\_enviado[15:0]} ([yshift=-.5*150/6]interno.north west);
			\draw[double,<-]([yshift=-1.5*150/6]mea.north east)--node[above]{Dato\_a\_enviar[15:0]}([yshift=-1.5*150/6]interno.north west);
			\draw[<-]([yshift=-2.5*150/6]mea.north east)--node[above]{Enviar\_datos}([yshift=-2.5*150/6]interno.north west);
			\draw[->]([yshift=-3.5*150/6]mea.north east)--node[above]{SLRD}([yshift=-3.5*150/6]interno.north west);
			\draw[->]([yshift=-4.5*150/6]mea.north east)--node[above]{SLWR}([yshift=-4.5*150/6]interno.north west);
			\draw[<-]([yshift=-5.5*150/6]mea.north east)--node[above]{PKTEND}([yshift=-5.5*150/6]interno.north west);
			
		\end{scope}
		\begin{scope}[]
			\node[rounded corners,inner ysep=5pt,draw=black,rectangle,fit={(mea)(interno)},label=north:FPGA](fpga){};
			\node[inner ysep=11pt, yshift= 8pt, draw=black,rectangle,fit={(fpga)(clkSrc)},label=north:Mojo](){};
		\end{scope}
	\end{tikzpicture}
	\caption{Diagrama en bloques del sistema de prueba}
	\label{test:sist}
\end{figure}

Para establecer un sistema eco, se deben implementar todas las señales de control que se observan en la Figura \ref{fpga:intersignal}. Estas son, señal de reset, señal de reloj, solicitud  sde envío de datos y los datos a enviar. A su vez, se deben poder leer los datos recibidos y las señales {\it SLWR} y {\it SLRD}, a través de las cuales el sistema señala el cambio de dato. 

Con el objetivo de poder recibir, almacear y reenviar los datos que llegan desde la interfaz, se sintetizó en el FPGA una memoria FIFO que almacene los datos y, cuando el EP de salida no posee más datos, es decir que el {\it Flag Vacío} se encuentra activo, retransmita los datos hacia la interfaz hasta que el Host los solicite.

Una vez incorporados los componentes al FPGA, se realizó su validación funcional antes de ser cargado todo el desarrollo al FPGA para efectuar las pruebas del sistema. A continuación, se detallarán los componentes y señales que se sintetizaron, como así también la verificación realizada.

\subsection{Declaración de la entidad}
	Para la implementación y síntesis del sistema, es necesario declarar los puertos que tendrán una correspondencia física con un pin de salida del FPGA en la descripción de mayor jerarquía. El archivo que posee una mayor jerarquía es usualmente llamada top.
	
	Como se conoce cuáles son las señales a través de las cuales el FPGA debe conectarse con la interfaz, es posible declarar la entidad que se sintetizó. Además se declararó  la señal de reloj, que proviene desde la placa Mojo v3. El código de descripción en donde se declaró la entidad se muestra a continuación.
	
	\begin{lstlisting}[language=VHDL,backgroundcolor=\color{gray!30}]
entity fx2lp_interface_top is
	generic(
		constant in_ep_addr:	std_logic_vector(1 downto 0) := "00";
		constant out_ep_addr:	std_logic_vector(1 downto 0) := "11";
		constant port_width: integer := 16
		);
	port(
		fdata   : inout std_logic_vector(port_width-1 downto 0);  
		faddr   : out   std_logic_vector(1 downto 0);
		slrd    : out   std_logic;
		slwr    : out   std_logic;
		flaga   : in    std_logic;
		flagb   : in    std_logic;
		flagc   : in    std_logic;
		flagd   : in    std_logic;
		sloe    : out   std_logic;
		pktend  : out   std_logic;
		clk_in  : in    std_logic
		);
end fx2lp_interface_top;
	\end{lstlisting}

\subsection{Instanciación de la MEF}
		Dentro de los componentes incorporado al sistema, el más importante es la MEF elaborada en el Capitulo \ref{cap:fpga}, debido a que es el componente que se desea sintetizar, verificar y probar. Para que el sistema reconozca que ese módulo debe incorporarlo al sistema, se declaró como componente los puertos de la entidad elaborada en el capítulo mencionado y se lo instanció como se observa a continuación.
		
		\begin{lstlisting}[language=VHDL,backgroundcolor=\color{gray!30}]
 architecture fx2lp_interface_arq of fx2lp_interface_top is
 	COMPONENT fx2lp_interface
	GENERIC(
		constant in_ep_addr:	std_logic_vector(1 downto 0) := "00";
		constant out_ep_addr:std_logic_vector(1 downto 0) := "11";
		constant port_width: integer := 16
	);
	PORT(
		clk : IN std_logic;
		reset : IN std_logic;
		flaga : IN std_logic;
		flagb : IN std_logic;
		flagc : IN std_logic;
		flagd : IN std_logic;
		send_req : IN std_logic;
		data_to_tx : IN std_logic_vector(15 downto 0);    
		fdata : INOUT std_logic_vector(15 downto 0);      
		faddr : OUT std_logic_vector(1 downto 0);
		slrd : OUT std_logic;
		slwr : OUT std_logic;
		sloe : OUT std_logic;
		pktend : OUT std_logic;
		rx_data : OUT std_logic_vector(15 downto 0)
		);
	END COMPONENT;
 begin
 	interface: fx2lp_interface PORT MAP(
		clk => sys_clk,
		reset => reset,
		fdata => fdata,
		faddr => faddr,
		slrd => slrd_sig,
		slwr => slwr_sig,
		flaga => flaga,
		flagb => flagb,
		flagc => flagc,
		flagd => flagd,
		sloe => sloe,
		pktend => pktend,
		send_req => write_req,
		rx_data => din,
		data_to_tx => dout
	);
[...]
end fx2lp_interface_arq;
		\end{lstlisting}
		
		Se puede observar que las constantes genéricas fueron definidas en la declaración del componente . Sin embargo, estas no fueron instanciadas debido a que la configuración a probar era la asignada por defecto.
		
\subsection{Otros componenetes y señales de control }

	\subsubsection{Generación de Señal de Reloj}
		Las especificaciones de la interfaz indican que la máxima frecuencia de funcionamiento del reloj debe ser de \SI{48}{\mega\hertz}\cite{Cypress2017}. La placa de desarrollo Mojo V3, por su parte, posee un oscilador que provee al FPGA una señal de \SI{50}{\mega\hertz}. Para lograr la señal de reloj con la frecuencia adecuada, se utiliza un PLL incorporado dentro del integrado del FPGA. 
		
		El PLL fue configurado a través de la herrmienta {\it Core Generator} provista por Xilinx junto con el entorno de desarrollo ISE, utilizado en este trabajo para el desarrollo\cite{XilinxInc}. A través de esta herramienta, se indicó que la señal de entrada es de \SI{50}{\mega\hertz}. Luego, con el objetivo de poseer señales de frecuencias diferentes por si se presentaran problemas de sincronismo, se seleccionaron señales de salida de \si{50}, \si{48}, \si{40} y \SI{35}{\mega\hertz}.
		
		La herramienta {\it Core Generator} de Xilinx entregó un código de VHDL en donde se declara una entidad para que pueda ser utilizada como componente y se instancia el PLL. Luego, la entidad de dicho código se declaró e instanció en la descripción del sistema de pruebas de la siguiente forma:
		
		\begin{lstlisting}[language=VHDL,backgroundcolor=\color{gray!30}]
architecture fx2lp_interface_arq of fx2lp_interface_top is
[...]
	component clk_wiz_v3_6
	port(
		CLK_IN1 : in  std_logic;
		CLK_OUT1: out std_logic;
		CLK_OUT2: out std_logic;
		CLK_OUT3: out std_logic;
		CLK_OUT4: out std_logic;
		RESET   : in  std_logic;
		LOCKED  : out std_logic
	);
	end component;
[...]
begin
	pll : clk_wiz_v3_6 
		port map(
			CLK_IN1   => clk_in,
			CLK_OUT1  => pll_50,
			CLK_OUT2  => pll_48,
			CLK_OUT3  => pll_40,
			CLK_OUT4  => pll_35,
			RESET     => '0',
			LOCKED    => locked
		);
	
		sys_clk <= pll_48;
[...]
end fx2lp_interface_arq;
		\end{lstlisting}
		
		Se puede notar que las señales {\it pll\_50}, {\it pll\_48}, {\it pll\_40} y {\it pll\_35} se utilizaron de manera especial para seleccionar en forma rápida la frecuencia que se le asigna a la señal de reloj del sistema. La señal asgnada al reloj del sistema fue la salida del PLL que posee una frecuencia de \SI{48}{\mega\hertz}.
		
	\subsubsection{Generación de señal de reset}
		La señal de reset fue generada por un contador con el objetivo de asegurar que, al conectar el FPGA, el sistema espere que finalice cualquier transitorio que pueda causar respuestas inesperadas e inicie con los valores iniciales preestablecidos.

		\begin{lstlisting}[language=VHDL,backgroundcolor=\color{gray!30}]
	init_rst: process(sys_clk)
	begin
		if rst_cont /= 0 then
			if rising_edge(sys_clk) then
				rst_cont <= rst_cont - 1;
			end if;
		end if;
	end process init_rst;
	
	reset <= '1' when rst_cont = 0 else '0';
		\end{lstlisting}
		
	\subsubsection{Implementación de la memoria FIFO en el FPGA}
		La memoria FIFO sintetizada en el FPGA también se obtuvo a través de la herramienta {\it Core Generator} de Xilinx. La configruación seleccionada generó una memoria FIFO de 511 bytes (la configuración de la herramienta pierde un byte al generar la memoria), con puertos de entrada y salida dedicados, es decir uno de entrada y uno de salida, un bus de 16 bits de ancho. Posee señal de reconocimiento de escritura. También se dotó a la memoria generada con entradas de reloj y habilitación de bus independientes tanto para el puerto de entrada como el puerto de salida.
		
		Con la configuración mencionada, {\it Core Generator} entregó una plantilla para utilizar la memoria generada. Esta plantilla se utilizó para declarar e instanciar el componente en el sistema implementado. 
		
		\begin{lstlisting}[language=VHDL,backgroundcolor=\color{gray!30}]
architecture fx2lp_interface_arq of fx2lp_interface_top is
[...]
	COMPONENT fifo_generator_v9_3
	  PORT (
		 rst : IN STD_LOGIC;
		 wr_clk : IN STD_LOGIC;
		 rd_clk : IN STD_LOGIC;
		 din : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
		 wr_en : IN STD_LOGIC;
		 rd_en : IN STD_LOGIC;
		 dout : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
		 full : OUT STD_LOGIC;
		 empty : OUT STD_LOGIC;
		 valid : OUT STD_LOGIC
	  );
	END COMPONENT;
[...]
begin
	fifo : fifo_generator_v9_3
	  PORT MAP (
		 rst => not reset,
		 wr_clk => sys_clk,
		 rd_clk => sys_clk,
		 din => din,
		 wr_en => wr_en,
		 rd_en => rd_en,
		 dout => dout,
		 full => fifo_full,
		 empty => fifo_empty,
		 valid => valid
	  );
[...]
end  fx2lp_interface_arq;
		\end{lstlisting}
		
		Luego, con todos los componentes declarados e instanciados, se elaboró una pequeña máquina de estados que sea capaz de colocar y extraer los datos en la memoria FIFO generada por la herramienta \textit{Core Generator}.